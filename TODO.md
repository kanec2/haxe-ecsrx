Цель 
Доработать проект haxe-ecsrx до состояния полнофункционального и стабильного фреймворка для разработки приложений на Haxe с использованием паттернов ECS и реактивного программирования, вдохновленного SystemsRx и EcsRx. 1. КРИТИЧЕСКИ ВАЖНО (Высокий приоритет) 1.1. Реализация PriorityUtils и поддержка приоритетов Задача: Создать утилиту PriorityUtils.orderByPriority для сортировки обработчиков систем и плагинов по приоритету. Что использовать: Макросы Haxe (haxe.macro.Context, haxe.macro.Type) для извлечения значения @:priority(NUM) из метаданных класса во время компиляции. it.itertools.Iter для сортировки массивов (Iter.sortBy). Как реализовать: Написать макрос PriorityUtils.getPriorityFromClass(cls:Class<T>):Int, который читает @:priority(X). Написать функцию orderByPriority<T>(items:Iterable<T>, getClazz:T->Class<Dynamic>):Array<T>, использующую макрос и Iter.sortBy. Интегрировать в SystemExecutor и SystemsRxApplication (для плагинов). Проверка: Тест SystemExecutorTests.should_run_systems_in_correct_priority должен проходить. Сложность: Средняя. 1.2. Исправление IEventSystem.receive<T>() и IMessageBroker.receive<T>() Задача: Устранить проблему невозможности получить Class<T> во время выполнения в Haxe. Что использовать: Альтернативные интерфейсы: IMessageReceiverHx.receive<T>(type:Class<T>):Observable<T> и IEventSystemHx.receive<T>(type:Class<T>):Observable<T>. Как реализовать: Создать новые интерфейсы IMessageReceiverHx, IMessageBrokerHx, IEventSystemHx. Адаптировать MessageBroker и EventSystem для работы с новыми интерфейсами. Обновить ReactToEventSystemHandler для использования IEventSystemHx. Проверка: Тесты ReactToEventSystemHandlerTests должны использовать новый API и проходить. Сложность: Средняя. 1.3. Завершение реализации обработчиков систем (ReactiveSystemHandler, ReactToEventSystemHandler) Задача: Реализовать логику подписки на события/потоки данных в ReactiveSystemHandler и ReactToEventSystemHandler. Что использовать: Макросы Haxe для генерации кода подписки под конкретные типы T. Или паттерн "регистрация обработчиков" в самих системах. Как реализовать (вариант 1 - Макросы): Создать макрос GenerateReactiveHandler, который для IReactiveSystem<MyData> генерирует код: system.reactTo().subscribe(system.execute). Аналогично для IReactToEventSystem<MyEvent>. Как реализовать (вариант 2 - Регистрация): Добавить в IReactiveSystem и IReactToEventSystem метод setupSubscriptions(eventSystemOrScheduler):Array<ISubscription>. Обработчики вызывают этот метод для настройки подписок. Проверка: Тесты ReactiveSystemHandlerTests, ReactToEventSystemHandlerTests должны проходить. Сложность: Высокая. 2. ВАЖНО (Средний приоритет) 2.1. Доработка и тестирование ReactiveProperty и ReactiveCollection Задача: Убедиться, что реализация полностью соответствует логике UniRx. Что использовать: Тесты ReactivePropertyTest и SanityTests из C#. rx.Subject, rx.Observable, rx.disposables.ISubscription. Как реализовать: Проверить и, при необходимости, исправить методы setValue, setValueAndForceNotify, hasValue, dispose. Убедиться в корректной работе с EqualityComparer (в Haxe используем == или haxe.ds.Equality). Проверить поведение при подписке (subscribe) на уже имеющееся значение (canPublishValueOnSubscribe). Проверка: Все тесты из ReactivePropertyTests.hx, SanityTests.hx должны проходить. Сложность: Средняя. 2.2. Интеграция с haxe-injection Задача: Убедиться, что адаптеры HaxeInjectionRegistry и HaxeInjectionResolver полностью соответствуют API haxe-injection. Что использовать: Документация и исходный код haxe-injection. Как реализовать: Проверить сигнатуры методов bind, bindInstance, resolve. Реализовать buildResolver() если это часть haxe-injection. Обработать canResolve. Проверка: Пример приложения, использующий DI, должен работать. Сложность: Низкая/Средняя. 2.3. Создание базовой реализации ISystemsRxApplication Задача: Создать рабочую реализацию SystemsRxApplication, которая может запускать системы. Что использовать: Уже реализованные компоненты: SystemExecutor, EventSystem, HaxeInjection*. Как реализовать: Завершить реализацию SystemsRxApplication (конструктор, startApplication, stopApplication). Убедиться, что loadModules загружает FrameworkModule. Убедиться, что bindSystems, startSystems работают (пусть даже с заглушками). Проверка: Простой пример приложения должен запускаться и останавливаться. Сложность: Средняя. 3. ПОЛЕЗНО (Низкий приоритет) 3.1. Расширение тестового покрытия Задача: Написать тесты для всех основных компонентов. Что использовать: utest или другой Haxe-совместимый фреймворк. Адаптированные тесты из C# SystemsRx.Tests. Как реализовать: Создать тесты для пулов (IdPoolTest, IndexPoolTest). Создать тесты для фабрик, вычисляемых значений, словарей. Создать интеграционные тесты для SystemExecutor и приложения. Проверка: Высокое покрытие кода тестами. Сложность: Средняя. 3.2. Создание примеров и документации Задача: Создать примеры использования и документацию. Что использовать: Простой пример игры или приложения. README.md с описанием архитектуры. Как реализовать: Создать папку /examples. Написать простой пример (например, счётчик с реактивным свойством и системой обновления). Описать основные компоненты в README. Проверка: Примеры должны компилироваться и работать. Сложность: Низкая. 3.3. Реализация других типов систем (если необходимо) Задача: Реализовать IReactToGroupSystem, IReactToDataSystem и т.д., если они понадобятся. Что использовать: Макросы или паттерн регистрации. Как реализовать: По аналогии с уже реализованными обработчиками. Сложность: Средняя. 4. ТЕХНИЧЕСКИЙ ДЛЯ КОНТРОЛЯ 4.1. Проверить все TODO и // Заглушка в коде. 4.2. Убедиться, что форматирование кода соответствует принятому стандарту. 4.3. Проверить зависимости проекта (haxe-concurrent, RxHaxe, haxe-injection, iter-tools).